import { assert, describe, expect, test } from "vitest";
import { exportedForTesting } from "../../../src/app/Stanc/Linting";

const { locationFromMessage, getWarningMessage, getErrorMessage } =
  exportedForTesting;

// all messages actually generated by stanc
const jacobianWarning = `Warning in 'jacobian.stan', line 1, column 12: Variable name 'jacobian' will
    be a reserved word starting in Stan 2.38.0. Please rename it!
`;

const multiColumnError = `Semantic error in 'multicol.stan', line 3, column 4 to column 10:
   -------------------------------------------------
     1:  parameters {
     2:      real y;
     3:      int x;
             ^
     4:  }
     5:  model {
   -------------------------------------------------

(Transformed) Parameters cannot be integers.
`;

const multiLineError = `Semantic error in 'multiline.stan', line 2, column 2 to line 4, column 16:
   -------------------------------------------------
     1:  generated quantities {
     2:    array[3] int x
           ^
     3:             =
     4:               10;
   -------------------------------------------------

Ill-typed arguments supplied to assignment operator =:
The left hand side has type
  array[] int
and the right hand side has type
  int
`;

describe("Linting", () => {
  describe("position detection", () => {
    test("random message returns undefined", () => {
      const message = "random message";
      const position = locationFromMessage(message);
      expect(position).toBeUndefined();
    });

    test("should detect the position of a single line, single column message", () => {
      const position = locationFromMessage(jacobianWarning);
      expect(position).toBeDefined();
      assert(position);
      expect(position.startLineNumber).toEqual(position.endLineNumber);
      expect(position.startColumn).toEqual(position.endColumn);

      expect(position.startLineNumber).toEqual(1);
      expect(position.startColumn).toEqual(13); // 0 vs 1 based indexing
    });

    test("should detect the position of a single line, multi-column error", () => {
      const position = locationFromMessage(multiColumnError);
      expect(position).toBeDefined();
      assert(position);
      expect(position.startLineNumber).toEqual(position.endLineNumber);
      expect(position.startColumn).not.toEqual(position.endColumn);

      expect(position.startLineNumber).toEqual(3);
      expect(position.startColumn).toEqual(5);
      expect(position.endColumn).toEqual(11);
    });

    test("should detect the position of a multi-line, multi-column error", () => {
      const position = locationFromMessage(multiLineError);
      expect(position).toBeDefined();
      assert(position);
      expect(position.startLineNumber).not.toEqual(position.endLineNumber);
      expect(position.startColumn).not.toEqual(position.endColumn);

      expect(position.startLineNumber).toEqual(2);
      expect(position.startColumn).toEqual(3);
      expect(position.endLineNumber).toEqual(4);
      expect(position.endColumn).toEqual(17);
    });
  });

  describe("message extraction", () => {
    test("should extract warning message without position", () => {
      const warningMessage = getWarningMessage(jacobianWarning);
      expect(warningMessage).toEqual(
        "Variable name 'jacobian' will be a reserved word starting in Stan 2.38.0. Please rename it!",
      );
    });

    test("should extract error message without position or snippet", () => {
      const errorMessage = getErrorMessage(multiColumnError);
      expect(errorMessage).toEqual(
        "(Transformed) Parameters cannot be integers.",
      );
    });

    test("should extract longer error message without position and snippet", () => {
      const errorMessage = getErrorMessage(multiLineError);
      expect(errorMessage).toEqual(
        `Ill-typed arguments supplied to assignment operator =:
The left hand side has type
  array[] int
and the right hand side has type
  int`,
      );
    });
  });
});
