import { assert, describe, expect, test } from "vitest";
import {
  exportedForTesting,
  stancErrorsToCodeMarkers,
} from "../../../src/app/Stanc/Linting";

const { locationFromMessage, getWarningMessage, getErrorMessage } =
  exportedForTesting;

// all messages actually generated by stanc
const jacobianWarning = `Warning in 'jacobian.stan', line 1, column 12: Variable name 'jacobian' will
    be a reserved word starting in Stan 2.38.0. Please rename it!
`;

// note: stanc can produce warnings like this that do not contain a position!
const emptyModelWarning = `Warning: Empty file 'empty.stan' detected; this is a valid stan model but
    likely unintended!`;

const multiColumnError = `Semantic error in 'multicol.stan', line 3, column 4 to column 10:
   -------------------------------------------------
     1:  parameters {
     2:      real y;
     3:      int x;
             ^
     4:  }
     5:  model {
   -------------------------------------------------

(Transformed) Parameters cannot be integers.
`;

const multiLineError = `Semantic error in 'multiline.stan', line 2, column 2 to line 4, column 16:
   -------------------------------------------------
     1:  generated quantities {
     2:    array[3] int x
           ^
     3:             =
     4:               10;
   -------------------------------------------------

Ill-typed arguments supplied to assignment operator =:
The left hand side has type
  array[] int
and the right hand side has type
  int
`;

describe("Linting", () => {
  describe("position detection", () => {
    test("empty message returns undefined", () => {
      const message = "";
      const position = locationFromMessage(message);
      expect(position).toBeUndefined();
    });

    test("message without position returns undefined", () => {
      const position = locationFromMessage(emptyModelWarning);
      expect(position).toBeUndefined();
    });

    test("should detect the position of a single line, single column message", () => {
      const position = locationFromMessage(jacobianWarning);
      expect(position).toBeDefined();
      assert(position);
      expect(position.startLineNumber).toEqual(position.endLineNumber);
      expect(position.startColumn).toEqual(position.endColumn);

      expect(position.startLineNumber).toEqual(1);
      // NOTE: stanc emits 0-based column numbers, but Monaco is 1-based
      expect(position.startColumn).toEqual(13);
    });

    test("should detect the position of a single line, multi-column error", () => {
      const position = locationFromMessage(multiColumnError);
      expect(position).toBeDefined();
      assert(position);
      expect(position.startLineNumber).toEqual(position.endLineNumber);
      expect(position.startColumn).not.toEqual(position.endColumn);

      expect(position.startLineNumber).toEqual(3);
      expect(position.startColumn).toEqual(5);
      expect(position.endColumn).toEqual(11);
    });

    test("should detect the position of a multi-line, multi-column error", () => {
      const position = locationFromMessage(multiLineError);
      expect(position).toBeDefined();
      assert(position);
      expect(position.startLineNumber).not.toEqual(position.endLineNumber);
      expect(position.startColumn).not.toEqual(position.endColumn);

      expect(position.startLineNumber).toEqual(2);
      expect(position.startColumn).toEqual(3);
      expect(position.endLineNumber).toEqual(4);
      expect(position.endColumn).toEqual(17);
    });
  });

  describe("message extraction", () => {
    test("should extract warning message without position", () => {
      const warningMessage = getWarningMessage(jacobianWarning);
      expect(warningMessage).toEqual(
        "Variable name 'jacobian' will be a reserved word starting in Stan 2.38.0. Please rename it!",
      );
    });

    test("should extract error message without position or snippet", () => {
      const errorMessage = getErrorMessage(multiColumnError);
      expect(errorMessage).toEqual(
        "(Transformed) Parameters cannot be integers.",
      );
    });

    test("should extract longer error message without position and snippet", () => {
      const errorMessage = getErrorMessage(multiLineError);
      expect(errorMessage).toEqual(
        `Ill-typed arguments supplied to assignment operator =:
The left hand side has type
  array[] int
and the right hand side has type
  int`,
      );
    });
  });

  describe("from Stanc Errors", () => {
    test("empty errors returns empty list", () => {
      const stancErrors = {};
      const codeMarkers = stancErrorsToCodeMarkers(stancErrors);
      expect(codeMarkers).toEqual([]);
    });

    test("bogus errors returns empty list", () => {
      const stancErrors = {
        errors: ["bogus error"],
        warnings: ["bogus warning"],
      };
      const codeMarkers = stancErrorsToCodeMarkers(stancErrors);
      expect(codeMarkers).toEqual([]);
    });

    test("single warning returns single warning marker", () => {
      const stancErrors = {
        warnings: [jacobianWarning],
      };
      const codeMarkers = stancErrorsToCodeMarkers(stancErrors);
      expect(codeMarkers).toHaveLength(1);
      expect(codeMarkers[0]?.severity).toEqual("warning");
    });

    test("single error returns single error marker", () => {
      const stancErrors = {
        errors: [multiColumnError],
      };
      const codeMarkers = stancErrorsToCodeMarkers(stancErrors);
      expect(codeMarkers).toHaveLength(1);
      expect(codeMarkers[0]?.severity).toEqual("error");
    });

    test("full stanc errors returns all markers", () => {
      const stancErrors = {
        errors: [multiColumnError, multiLineError],
        warnings: [jacobianWarning, jacobianWarning, jacobianWarning],
      };
      const codeMarkers = stancErrorsToCodeMarkers(stancErrors);
      expect(codeMarkers).toHaveLength(5);
    });
  });
});
